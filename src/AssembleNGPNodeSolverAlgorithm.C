/*------------------------------------------------------------------------*/
/*  Copyright 2019 National Renewable Energy Laboratory.                  */
/*  This software is released under the license detailed                  */
/*  in the file, LICENSE, which is located in the top-level Nalu          */
/*  directory structure                                                   */
/*------------------------------------------------------------------------*/

#include "AssembleNGPNodeSolverAlgorithm.h"
#include "EquationSystem.h"
#include "KokkosInterface.h"
#include "LinearSystem.h"
#include "Realm.h"

#include "node_kernels/NodeKernel.h"

namespace sierra {
namespace nalu {

namespace {
inline int calc_shmem_bytes_per_thread(int rhsSize)
{
  // LHS (RHS^2) + RHS
  const int matSize = rhsSize * (1 + rhsSize) * sizeof(double);
  // Scratch IDs and search permutations (will be optimized later)
  const int idSize = 2 * rhsSize * sizeof(int);

  return (matSize + idSize);
}

template<typename TEAMHANDLETYPE, typename SHMEM>
struct SharedMemData_Node {
  KOKKOS_FUNCTION
  SharedMemData_Node(
    const TEAMHANDLETYPE& team,
    unsigned rhsSize
  ) : ngpNodes(nodeID, 1)
  {
    rhs = get_shmem_view_1D<double, TEAMHANDLETYPE, SHMEM>(team, rhsSize);
    lhs = get_shmem_view_2D<double, TEAMHANDLETYPE, SHMEM>(team, rhsSize, rhsSize);
    scratchIds = get_shmem_view_1D<int,TEAMHANDLETYPE,SHMEM>(team, rhsSize);
    sortPermutation = get_shmem_view_1D<int,TEAMHANDLETYPE,SHMEM>(team, rhsSize);
  }

  stk::mesh::Entity nodeID[1];
  ngp::Mesh::ConnectedNodes ngpNodes;
  SharedMemView<double*,SHMEM> rhs;
  SharedMemView<double**,SHMEM> lhs;

  SharedMemView<int*,SHMEM> scratchIds;
  SharedMemView<int*,SHMEM> sortPermutation;
};
}

AssembleNGPNodeSolverAlgorithm::AssembleNGPNodeSolverAlgorithm(
  Realm& realm,
  stk::mesh::Part* part,
  EquationSystem* eqSystem
) : SolverAlgorithm(realm, part, eqSystem),
    rhsSize_(eqSystem->linsys_->numDof())
{}

AssembleNGPNodeSolverAlgorithm::~AssembleNGPNodeSolverAlgorithm()
{
  // Release the device pointers if any
  for (auto& kern: nodeKernels_) {
    kern->free_on_device();
  }
}

void
AssembleNGPNodeSolverAlgorithm::initialize_connectivity()
{
  eqSystem_->linsys_->buildNodeGraph(partVec_);
}

void
AssembleNGPNodeSolverAlgorithm::execute()
{
  using ShmemDataType = SharedMemData_Node<DeviceTeamHandleType, DeviceShmem>;

  const size_t numKernels = nodeKernels_.size();
  if (numKernels < 1) return;

  for (auto& kern: nodeKernels_)
    kern->setup(realm_);

  auto ngpKernels = nalu_ngp::create_ngp_view<NodeKernel>(nodeKernels_);

  const auto& meta = realm_.meta_data();
  const auto& ngpMesh = realm_.ngp_mesh();
  const stk::mesh::EntityRank entityRank = stk::topology::NODE_RANK;
  const int rhsSize = rhsSize_;

#ifdef KOKKOS_ENABLE_CUDA
  CoeffApplier* coeffApplier = eqSystem_->linsys_->get_coeff_applier();
  CoeffApplier* deviceCoeffApplier = coeffApplier->device_pointer();
#endif

  const int nodesPerEntity = 1;
  const int bytes_per_team = 0;
  const int bytes_per_thread = calc_shmem_bytes_per_thread(rhsSize);

  stk::mesh::Selector sel = meta.locally_owned_part()
    & stk::mesh::selectUnion(partVec_)
    & !(stk::mesh::selectUnion(realm_.get_slave_part_vector()))
    & !(realm_.get_inactive_selector());
  const auto& buckets = ngp::get_bucket_ids(realm_.bulk_data(), entityRank, sel);

  auto team_exec = get_device_team_policy(buckets.size(), bytes_per_team, bytes_per_thread);

  Kokkos::parallel_for(
    team_exec, KOKKOS_LAMBDA(const DeviceTeamHandleType& team) {
      auto bktId = buckets.device_get(team.league_rank());
      auto& b = ngpMesh.get_bucket(entityRank, bktId);

      ShmemDataType smdata(team, rhsSize);

      const size_t bktLen = b.size();
      Kokkos::parallel_for(
        Kokkos::TeamThreadRange(team, bktLen),
        [&](const size_t& bktIndex) {
          auto node = b[bktIndex];
          const auto nodeIndex = ngpMesh.fast_mesh_index(node);
          smdata.nodeID[0] = node;

          set_zero(smdata.rhs.data(), smdata.rhs.size());
          set_zero(smdata.lhs.data(), smdata.lhs.size());

          for (size_t i=0; i < numKernels; ++i) {
            NodeKernel* kernel = ngpKernels(i);
            kernel->execute(smdata.lhs, smdata.rhs, nodeIndex);
          }

#ifndef KOKKOS_ENABLE_CUDA
          this->apply_coeff(
            nodesPerEntity, smdata.ngpNodes, smdata.scratchIds,
            smdata.sortPermutation, smdata.rhs, smdata.lhs, __FILE__);
#else
          (*deviceCoeffApplier)(
            nodesPerEntity, smdata.ngpNodes, smdata.scratchIds,
            smdata.sortPermutation, smdata.rhs, smdata.lhs, __FILE__);
#endif
        });
    });
#ifdef KOKKOS_ENABLE_CUDA
    coeffApplier->free_device_pointer();
    delete coeffApplier;
#endif
}

}  // nalu
}  // sierra
